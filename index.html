<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Sprinkler Runtime Calculator</title>
<style>
  /* Reset & base */
  *, *::before, *::after {
    box-sizing: border-box;
  }
  body {
    font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    margin: 1.5rem;
    max-width: 650px;
    background: #f4f7f9;
    color: #222;
  }
  h1 {
    text-align: center;
    margin-bottom: 0.2rem;
    color: #2c3e50;
  }
  #description {
    font-size: 0.9rem;
    color: #555;
    margin-bottom: 1.4rem;
    line-height: 1.4;
  }

  /* Inputs and labels */
  label {
    display: block;
    font-weight: 600;
    margin-top: 1.1rem;
    margin-bottom: 0.25rem;
    color: #34495e;
  }
  input[type="number"], input[type="text"] {
    width: 100%;
    padding: 0.5rem 0.65rem;
    font-size: 1rem;
    border: 1.5px solid #ccc;
    border-radius: 6px;
    transition: border-color 0.3s;
  }
  input[type="number"]:focus, input[type="text"]:focus {
    border-color: #2980b9;
    outline: none;
  }
  input[readonly] {
    background: #eee;
  }

  /* Sprinkler zones container */
  #zones-container {
    margin-top: 1rem;
    border: 1px solid #d1d9e6;
    border-radius: 8px;
    background: white;
    padding: 0.5rem 0.75rem 0.25rem 0.75rem;
  }
  #zones-labels {
    display: flex;
    font-weight: 700;
    color: #2c3e50;
    border-bottom: 1px solid #ccc;
    padding-bottom: 0.3rem;
  }
  #zones-labels > div {
    flex: 1;
    padding-left: 0.3rem;
  }
  #zones-labels > div:nth-child(2) {
    max-width: 130px;
  }
  .zone-row {
    display: flex;
    margin-top: 0.4rem;
    align-items: center;
  }
  .zone-row > input {
    flex: 1;
    margin-right: 0.5rem;
  }
  .zone-row > input.rate {
    max-width: 130px;
  }
  .remove-zone-btn {
    background: #e74c3c;
    border: none;
    color: white;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1.15rem;
    line-height: 1;
    padding: 2px 8px;
    transition: background-color 0.2s;
  }
  .remove-zone-btn:hover {
    background: #c0392b;
  }
  #add-zone-btn {
    margin-top: 0.6rem;
    background: #27ae60;
    border: none;
    color: white;
    font-weight: 600;
    border-radius: 6px;
    padding: 0.45rem 1rem;
    cursor: pointer;
    font-size: 1rem;
    transition: background-color 0.3s;
    width: 100%;
  }
  #add-zone-btn:hover {
    background: #1e8449;
  }

  /* Other controls */
  #controls {
    margin-top: 1.25rem;
  }
  #controls > div {
    margin-top: 0.9rem;
  }

  /* Buttons */
  button {
    cursor: pointer;
    border: none;
    border-radius: 6px;
    padding: 0.6rem 1.2rem;
    font-size: 1.1rem;
    font-weight: 700;
    transition: background-color 0.3s ease;
  }
  #calculateBtn {
    background-color: #2980b9;
    color: white;
    width: 100%;
    margin-top: 1.7rem;
  }
  #calculateBtn:hover:not(:disabled) {
    background-color: #1c5980;
  }
  #resetBtn {
    background-color: #7f8c8d;
    color: white;
    margin-top: 0.7rem;
    width: 100%;
  }
  #resetBtn:hover {
    background-color: #626c6f;
  }
  #locationBtn {
    background-color: #3498db;
    color: white;
    margin-top: 0.7rem;
    width: 100%;
  }
  #locationBtn:hover {
    background-color: #217dbb;
  }

  /* Result area */
  #results {
    margin-top: 1.8rem;
    padding: 1rem;
    background: white;
    border-radius: 8px;
    box-shadow: 0 0 6px rgba(0,0,0,0.08);
    white-space: pre-line;
    font-family: "Courier New", Courier, monospace;
    font-size: 1.05rem;
    color: #2c3e50;
    display: none;
  }

  /* Error message styling */
  #formula-error, #location-error {
    margin-top: 0.5rem;
    color: #c0392b;
    font-weight: 700;
  }

  /* Formula builder */
  #formula-builder {
    margin-top: 1.2rem;
    background: white;
    padding: 0.75rem 1rem;
    border-radius: 8px;
    border: 1.5px solid #d1d9e6;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
  }
  #formula-builder h2 {
    margin-top: 0;
    font-size: 1.1rem;
    font-weight: 700;
    color: #34495e;
    margin-bottom: 0.7rem;
  }

  /* Formula builder workspace */
  #formula-workspace {
    min-height: 48px;
    border: 1.5px solid #ccc;
    border-radius: 6px;
    padding: 0.3rem 0.5rem;
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    background: #fafafa;
  }
  .formula-token {
    user-select: none;
    padding: 0.3rem 0.65rem;
    margin: 0 0.25rem 0.3rem 0.25rem;
    border-radius: 5px;
    cursor: grab;
    font-weight: 600;
    font-size: 1rem;
    white-space: nowrap;
    box-shadow: 0 1px 2px rgb(0 0 0 / 0.1);
    border: 1px solid transparent;
    transition: box-shadow 0.2s, border-color 0.2s;
  }
  .formula-token:active {
    cursor: grabbing;
  }
  .variable-token {
    background-color: #3498db;
    color: white;
  }
  .operator-token {
    background-color: #e67e22;
    color: white;
  }
  .number-token {
    background-color: #9b59b6;
    color: white;
  }

  /* Formula tokens palette */
  #token-palette {
    margin-top: 0.7rem;
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }
  #token-palette button {
    cursor: pointer;
    border: none;
    padding: 0.45rem 0.9rem;
    border-radius: 6px;
    font-weight: 600;
    font-size: 1rem;
    color: white;
    box-shadow: 0 1px 3px rgb(0 0 0 / 0.15);
    transition: background-color 0.3s ease;
  }
  #token-palette button.variable {
    background-color: #2980b9;
  }
  #token-palette button.operator {
    background-color: #d35400;
  }
  #token-palette button.number {
    background-color: #8e44ad;
  }

  /* Responsive */
  @media (max-width: 480px) {
    #zones-labels, .zone-row {
      flex-direction: column;
      align-items: flex-start;
    }
    #zones-labels > div, .zone-row > input.rate {
      max-width: 100% !important;
      margin-bottom: 0.3rem;
    }
    .remove-zone-btn {
      align-self: flex-start;
    }
  }
</style>
</head>
<body>

<h1>Sprinkler Runtime Calculator</h1>
<div id="description">
  This calculator estimates how long to run each sprinkler zone based on the weekly Reference Evapotranspiration (ET) and predicted rainfall.
  <br/><br/>
  <strong>Formula used for runtime per zone (in minutes):</strong><br/>
  <code>Runtime = watering frequency × (ET replacement % × Weekly ET - Weekly Rainfall) × Minutes per 1" water for zone</code>
  <br/><br/>
  Adjust watering frequency and ET replacement % to your needs, add your sprinkler zones, then press Calculate.
</div>

<!-- Location Inputs -->
<label for="latitude">Latitude (decimal degrees)</label>
<input type="number" id="latitude" step="0.0001" placeholder="e.g. 47.94" />
<label for="longitude">Longitude (decimal degrees)</label>
<input type="number" id="longitude" step="0.0001" placeholder="e.g. -122.21" />
<button id="locationBtn" type="button">Use My Location</button>
<div id="location-error" role="alert" aria-live="assertive"></div>

<!-- Sprinkler zones -->
<label>Sprinkler Zones</label>
<div id="zones-container" aria-label="Sprinkler zones list">
  <div id="zones-labels">
    <div>Zone Name</div>
    <div>Minutes per 1&quot; Water</div>
    <div></div>
  </div>
  <!-- zone rows will be inserted here dynamically -->
</div>
<button id="add-zone-btn" type="button" aria-label="Add sprinkler zone">+ Add Zone</button>

<!-- Other controls -->
<div id="controls">
  <div>
    <label for="watering-frequency">Watering Frequency (water every X days)</label>
    <input type="number" id="watering-frequency" min="0.1" step="0.1" placeholder="e.g. 2 (default: 2 days)" />
  </div>
  <div>
    <label for="et-replacement">ET Replacement Percentage (e.g. 75 for 75%)</label>
    <input type="number" id="et-replacement" min="0" max="100" step="1" placeholder="e.g. 75 (default: 75%)" />
  </div>
</div>

<!-- Formula Builder -->
<div id="formula-builder" aria-label="Custom formula builder">
  <h2>Custom Runtime Formula Builder (optional)</h2>
  <div id="formula-workspace" aria-live="polite" aria-label="Formula workspace" tabindex="0" aria-describedby="formula-instructions"></div>
  <div id="formula-instructions" style="font-size:0.85rem; color:#555; margin-top:0.2rem;">
    Drag tokens below to build your formula. Variables: <code>ET</code>, <code>R</code>, <code>W</code> (watering frequency), <code>Rate</code>.<br />
    Use operators (+, -, *, /) and numbers. Formula should return runtime in minutes.<br/>
    Default formula is: <code>W * (ET * (ETreplace/100) - R) * Rate</code>
  </div>
  <div id="token-palette" aria-label="Formula tokens palette">
    <!-- Variables -->
    <button type="button" class="variable" data-token="ET">ET</button>
    <button type="button" class="variable" data-token="R">R</button>
    <button type="button" class="variable" data-token="W">W</button>
    <button type="button" class="variable" data-token="Rate">Rate</button>
    <button type="button" class="operator" data-token="+">+</button>
    <button type="button" class="operator" data-token="-">−</button>
    <button type="button" class="operator" data-token="*">×</button>
    <button type="button" class="operator" data-token="/">÷</button>
    <button type="button" class="number" data-token="1">1</button>
    <button type="button" class="number" data-token="2">2</button>
    <button type="button" class="number" data-token="3">3</button>
    <button type="button" class="number" data-token="4">4</button>
    <button type="button" class="number" data-token="5">5</button>
    <button type="button" class="number" data-token="6">6</button>
    <button type="button" class="number" data-token="7">7</button>
    <button type="button" class="number" data-token="8">8</button>
    <button type="button" class="number" data-token="9">9</button>
    <button type="button" class="number" data-token="0">0</button>
    <button type="button" class="number" data-token=".">.</button>
  </div>
  <button id="clear-formula" type="button" style="margin-top:0.8rem; background:#c0392b; color:white; width:100%; font-weight:700; border-radius:6px;">Clear Formula</button>
  <div id="formula-error" role="alert" aria-live="assertive"></div>
</div>

<button id="calculateBtn" type="button" aria-label="Calculate sprinkler runtimes">Calculate Runtime</button>
<button id="resetBtn" type="button" aria-label="Reset all inputs to defaults">Reset to Defaults</button>

<div id="results" aria-live="polite" role="region" aria-label="Calculation results"></div>

<script>
(() => {
  "use strict";

  // Constants for localStorage keys
  const STORAGE_KEYS = {
    latitude: "sprinklerCalc_latitude",
    longitude: "sprinklerCalc_longitude",
    zones: "sprinklerCalc_zones",
    wateringFrequency: "sprinklerCalc_wateringFrequency",
    etReplacement: "sprinklerCalc_etReplacement",
    formulaTokens: "sprinklerCalc_formulaTokens",
  };

  // Elements
  const latitudeInput = document.getElementById("latitude");
  const longitudeInput = document.getElementById("longitude");
  const locationBtn = document.getElementById("locationBtn");
  const locationError = document.getElementById("location-error");

  const zonesContainer = document.getElementById("zones-container");
  const addZoneBtn = document.getElementById("add-zone-btn");

  const wateringFreqInput = document.getElementById("watering-frequency");
  const etReplacementInput = document.getElementById("et-replacement");

  const formulaWorkspace = document.getElementById("formula-workspace");
  const formulaError = document.getElementById("formula-error");
  const tokenPalette = document.getElementById("token-palette");
  const clearFormulaBtn = document.getElementById("clear-formula");

  const calculateBtn = document.getElementById("calculateBtn");
  const resetBtn = document.getElementById("resetBtn");

  const resultsDiv = document.getElementById("results");

  // Default values (used internally only)
  const DEFAULT_WATERING_FREQUENCY = 2; // days between watering
  const DEFAULT_ET_REPLACEMENT = 75; // percent

  // Formula tokens are stored as an array of strings e.g. ["W", "*", "(", "ET", "*", "(", "ETreplace", "/", "100", ")", "-", "R", ")", "*", "Rate"]
  // We'll simplify: ETreplace is from input, so in formula builder user just uses ET, R, W, Rate.
  // We'll replace ETreplace with its input in evaluation.

  // Zone row HTML template function
  function createZoneRow(name = "", rate = "") {
    const row = document.createElement("div");
    row.className = "zone-row";

    const nameInput = document.createElement("input");
    nameInput.type = "text";
    nameInput.className = "zone-name";
    nameInput.placeholder = "Zone name";
    nameInput.value = name;

    const rateInput = document.createElement("input");
    rateInput.type = "number";
    rateInput.min = "0";
    rateInput.step = "0.1";
    rateInput.className = "rate";
    rateInput.placeholder = "Minutes per 1\" water";
    rateInput.value = rate;

    const removeBtn = document.createElement("button");
    removeBtn.type = "button";
    removeBtn.className = "remove-zone-btn";
    removeBtn.title = "Remove this zone";
    removeBtn.setAttribute("aria-label", `Remove zone ${name || "unnamed"}`);
    removeBtn.textContent = "✕";

    removeBtn.addEventListener("click", () => {
      zonesContainer.removeChild(row);
      saveZonesToStorage();
    });

    row.appendChild(nameInput);
    row.appendChild(rateInput);
    row.appendChild(removeBtn);

    // Save changes on input for live localStorage updates
    [nameInput, rateInput].forEach(input => {
      input.addEventListener("input", saveZonesToStorage);
    });

    return row;
  }

  // Add zone row to container
  function addZone(name = "", rate = "") {
    zonesContainer.appendChild(createZoneRow(name, rate));
  }

  // Load zones from storage
  function loadZonesFromStorage() {
    zonesContainer.innerHTML = "";
    try {
      const savedZones = JSON.parse(localStorage.getItem(STORAGE_KEYS.zones));
      if (Array.isArray(savedZones) && savedZones.length) {
        savedZones.forEach(({name, rate}) => addZone(name, rate));
      } else {
        // Add one empty zone row by default
        addZone();
      }
    } catch {
      addZone();
    }
  }

  // Save zones to storage
  function saveZonesToStorage() {
    const zones = [];
    [...zonesContainer.children].forEach(row => {
      const name = row.querySelector(".zone-name").value.trim();
      const rate = row.querySelector(".rate").value.trim();
      if (name && rate && !isNaN(rate)) {
        zones.push({ name, rate: parseFloat(rate) });
      }
    });
    localStorage.setItem(STORAGE_KEYS.zones, JSON.stringify(zones));
  }

  // Save all inputs to storage
  function saveAllInputsToStorage() {
    localStorage.setItem(STORAGE_KEYS.latitude, latitudeInput.value.trim());
    localStorage.setItem(STORAGE_KEYS.longitude, longitudeInput.value.trim());
    localStorage.setItem(STORAGE_KEYS.wateringFrequency, wateringFreqInput.value.trim());
    localStorage.setItem(STORAGE_KEYS.etReplacement, etReplacementInput.value.trim());
    saveZonesToStorage();
    saveFormulaTokensToStorage();
  }

  // Load all inputs from storage
  function loadAllInputsFromStorage() {
    const lat = localStorage.getItem(STORAGE_KEYS.latitude);
    if (lat !== null) latitudeInput.value = lat;

    const lon = localStorage.getItem(STORAGE_KEYS.longitude);
    if (lon !== null) longitudeInput.value = lon;

    const wf = localStorage.getItem(STORAGE_KEYS.wateringFrequency);
    if (wf !== null) wateringFreqInput.value = wf;

    const etr = localStorage.getItem(STORAGE_KEYS.etReplacement);
    if (etr !== null) etReplacementInput.value = etr;

    loadZonesFromStorage();
    loadFormulaTokensFromStorage();
  }

  // Reset to defaults with confirmation
  function resetToDefaults() {
    if (!confirm("Are you sure you want to reset all inputs to defaults? This will clear all your data.")) return;

    latitudeInput.value = "";
    longitudeInput.value = "";
    wateringFreqInput.value = "";
    etReplacementInput.value = "";

    zonesContainer.innerHTML = "";
    addZone();

    formulaTokens = defaultFormulaTokens.slice();
    renderFormulaWorkspace();
    formulaError.textContent = "";

    resultsDiv.style.display = "none";
    resultsDiv.textContent = "";

    // Clear storage
    Object.values(STORAGE_KEYS).forEach(key => localStorage.removeItem(key));
  }

  // Location fetching
  locationBtn.addEventListener("click", () => {
    locationError.textContent = "";
    locationBtn.disabled = true;
    locationBtn.textContent = "Getting location...";
    if (!navigator.geolocation) {
      locationError.textContent = "Geolocation is not supported by your browser.";
      locationBtn.disabled = false;
      locationBtn.textContent = "Use My Location";
      return;
    }
    navigator.geolocation.getCurrentPosition(
      pos => {
        latitudeInput.value = pos.coords.latitude.toFixed(5);
        longitudeInput.value = pos.coords.longitude.toFixed(5);
        saveAllInputsToStorage();
        locationBtn.disabled = false;
        locationBtn.textContent = "Use My Location";
      },
      err => {
        locationError.textContent = `Could not get location: ${err.message}`;
        locationBtn.disabled = false;
        locationBtn.textContent = "Use My Location";
      },
      {timeout:10000}
    );
  });

  // Formula builder variables
  // Tokens and logic for drag/drop & validation

  // Token types: variable, operator, number
  // Default formula tokens (W * (ET * (ETreplace/100) - R) * Rate)
  // We'll integrate ETreplace from input, so formula uses W, ET, R, Rate
  // We store tokens as an array of strings (tokens): e.g. ["W", "*", "(", "ET", "*", "0.75", "-", "R", ")", "*", "Rate"]
  // For user ease, we skip parentheses and use operator precedence by eval

  // Start with a simpler formula:
  // W * (ET * (ETreplace/100) - R) * Rate
  // But user builds only using tokens W, ET, R, Rate, numbers, operators (+, -, *, /)

  let formulaTokens = [];

  const defaultFormulaTokens = ["W", "*", "(", "ET", "*", "0.75", "-", "R", ")", "*", "Rate"];

  // For ease in drag/drop, parentheses tokens will be added by user if wanted but not required

  // Render formula workspace tokens
  function renderFormulaWorkspace() {
    formulaWorkspace.innerHTML = "";
    formulaTokens.forEach((token, idx) => {
      const tokenEl = document.createElement("div");
      tokenEl.classList.add("formula-token");
      tokenEl.textContent = token;

      // Determine token type
      if (["ET", "R", "W", "Rate"].includes(token)) {
        tokenEl.classList.add("variable");
      } else if (["+", "-", "*", "/"].includes(token)) {
        tokenEl.classList.add("operator");
      } else {
        tokenEl.classList.add("number");
      }

      tokenEl.setAttribute("draggable", "true");
      tokenEl.setAttribute("aria-grabbed", "false");
      tokenEl.setAttribute("tabindex", "0");
      tokenEl.setAttribute("role", "button");
      tokenEl.setAttribute("aria-label", `Formula token ${token}`);

      tokenEl.addEventListener("dragstart", onDragStart);
      tokenEl.addEventListener("dragend", onDragEnd);
      tokenEl.addEventListener("keydown", onTokenKeyDown);

      formulaWorkspace.appendChild(tokenEl);
    });
  }

  // Save formula tokens to storage
  function saveFormulaTokensToStorage() {
    localStorage.setItem(STORAGE_KEYS.formulaTokens, JSON.stringify(formulaTokens));
  }

  // Load formula tokens from storage
  function loadFormulaTokensFromStorage() {
    const stored = localStorage.getItem(STORAGE_KEYS.formulaTokens);
    if (stored) {
      try {
        const tokens = JSON.parse(stored);
        if (Array.isArray(tokens) && tokens.length) {
          formulaTokens = tokens;
          renderFormulaWorkspace();
          return;
        }
      } catch {}
    }
    formulaTokens = defaultFormulaTokens.slice();
    renderFormulaWorkspace();
  }

  // Add token from palette to formula
  tokenPalette.addEventListener("click", (e) => {
    if (e.target.tagName !== "BUTTON") return;
    const token = e.target.dataset.token;
    if (!token) return;

    // Add token to formula
    formulaTokens.push(token);
    renderFormulaWorkspace();
    saveFormulaTokensToStorage();
    formulaError.textContent = "";
  });

  // Clear formula
  clearFormulaBtn.addEventListener("click", () => {
    formulaTokens = [];
    renderFormulaWorkspace();
    saveFormulaTokensToStorage();
    formulaError.textContent = "";
  });

  // Drag & drop logic for formula tokens
  let draggedIndex = null;

  function onDragStart(e) {
    draggedIndex = [...formulaWorkspace.children].indexOf(e.target);
    e.dataTransfer.effectAllowed = "move";
    e.dataTransfer.setData("text/plain", draggedIndex);
    e.target.setAttribute("aria-grabbed", "true");
  }

  function onDragEnd(e) {
    e.target.setAttribute("aria-grabbed", "false");
    draggedIndex = null;
  }

  formulaWorkspace.addEventListener("dragover", (e) => {
    e.preventDefault();
  });

  formulaWorkspace.addEventListener("drop", (e) => {
    e.preventDefault();
    const fromIndex = draggedIndex;
    if (fromIndex === null) return;

    const toIndex = [...formulaWorkspace.children].indexOf(e.target.closest(".formula-token"));
    if (toIndex === -1 || toIndex === fromIndex) return;

    // Move token in array
    const [moved] = formulaTokens.splice(fromIndex, 1);
    formulaTokens.splice(toIndex, 0, moved);

    renderFormulaWorkspace();
    saveFormulaTokensToStorage();
  });

  // Keyboard support for token reordering
  function onTokenKeyDown(e) {
    const tokenEl = e.target;
    const idx = [...formulaWorkspace.children].indexOf(tokenEl);
    if (idx === -1) return;

    switch (e.key) {
      case "ArrowLeft":
      case "ArrowUp":
        if (idx > 0) {
          // Swap with previous
          [formulaTokens[idx - 1], formulaTokens[idx]] = [formulaTokens[idx], formulaTokens[idx - 1]];
          renderFormulaWorkspace();
          saveFormulaTokensToStorage();
          formulaWorkspace.children[idx - 1].focus();
          e.preventDefault();
        }
        break;
      case "ArrowRight":
      case "ArrowDown":
        if (idx < formulaTokens.length - 1) {
          // Swap with next
          [formulaTokens[idx + 1], formulaTokens[idx]] = [formulaTokens[idx], formulaTokens[idx + 1]];
          renderFormulaWorkspace();
          saveFormulaTokensToStorage();
          formulaWorkspace.children[idx + 1].focus();
          e.preventDefault();
        }
        break;
      case "Delete":
      case "Backspace":
        formulaTokens.splice(idx, 1);
        renderFormulaWorkspace();
        saveFormulaTokensToStorage();
        // Focus next token or formula workspace
        if (formulaTokens.length > 0) {
          formulaWorkspace.children[Math.min(idx, formulaTokens.length - 1)].focus();
        } else {
          formulaWorkspace.focus();
        }
        e.preventDefault();
        break;
      default:
        break;
    }
  }

  // Validate formula tokens for safety and correctness
  function validateFormula(tokens) {
    if (tokens.length === 0) {
      return "Formula cannot be empty.";
    }

    const validTokens = new Set(["ET", "R", "W", "Rate", "+", "-", "*", "/", "(", ")", "."]);
    const validVariables = new Set(["ET", "R", "W", "Rate"]);

    let balance = 0; // parentheses balance
    let lastToken = null;
    let lastWasOperator = false;

    for (const token of tokens) {
      if (token === "(") {
        balance++;
      } else if (token === ")") {
        balance--;
        if (balance < 0) return "Mismatched parentheses.";
      } else if (!validTokens.has(token) && isNaN(token)) {
        return `Invalid token: ${token}`;
      }

      // Check operator placement
      if (["+", "-", "*", "/"].includes(token)) {
        if (lastWasOperator || lastToken === null) {
          return "Two operators in a row or operator at start.";
        }
        lastWasOperator = true;
      } else if (token !== "(" && token !== ")") {
        lastWasOperator = false;
      }

      lastToken = token;
    }

    if (balance !== 0) {
      return "Mismatched parentheses.";
    }

    if (["+", "-", "*", "/"].includes(tokens[tokens.length - 1])) {
      return "Formula cannot end with an operator.";
    }

    return null; // no errors
  }

  // Evaluate formula for a zone, replacing tokens by values
  function evaluateFormula(tokens, values) {
    // values: {ET, R, W, Rate, ETreplace (as decimal)}
    // We'll replace "ETreplace" tokens with (ET * ETreplace/100) manually in formula
    // Our formula tokens do not include ETreplace token but include numbers (like 0.75 for 75%)

    // Build expression string
    let expr = "";

    tokens.forEach(token => {
      if (token === "ET") {
        expr += `(${values.ET})`;
      } else if (token === "R") {
        expr += `(${values.R})`;
      } else if (token === "W") {
        expr += `(${values.W})`;
      } else if (token === "Rate") {
        expr += `(${values.Rate})`;
      } else if (token === "(" || token === ")") {
        expr += token;
      } else if (!isNaN(token)) {
        expr += token;
      } else if (["+", "-", "*", "/"].includes(token)) {
        expr += token;
      } else {
        throw new Error(`Unknown token during evaluation: ${token}`);
      }
    });

    // Evaluate safely using Function constructor
    try {
      // Note: No external inputs except controlled values
      // eslint-disable-next-line no-new-func
      const func = new Function(`return ${expr};`);
      const result = func();
      if (typeof result !== "number" || isNaN(result)) {
        throw new Error("Invalid formula evaluation result.");
      }
      return result;
    } catch (e) {
      throw new Error(`Error evaluating formula: ${e.message}`);
    }
  }

  // Calculate runtimes and display results
  calculateBtn.addEventListener("click", () => {
    formulaError.textContent = "";
    resultsDiv.style.display = "block";
    resultsDiv.innerHTML = "";

    // Validate formula first
    const validationError = validateFormula(formulaTokens);
    if (validationError) {
      formulaError.textContent = `Formula error: ${validationError}`;
      resultsDiv.style.display = "none";
      return;
    }

    // Get inputs
    const wateringFrequency = parseFloat(wateringFreqInput.value);
    const etReplacementPercent = parseFloat(etReplacementInput.value) || DEFAULT_ET_REPLACEMENT;

    if (isNaN(wateringFrequency) || wateringFrequency <= 0) {
      formulaError.textContent = "Invalid watering frequency.";
      resultsDiv.style.display = "none";
      return;
    }
    if (isNaN(etReplacementPercent) || etReplacementPercent <= 0 || etReplacementPercent > 100) {
      formulaError.textContent = "Invalid ET replacement percentage.";
      resultsDiv.style.display = "none";
      return;
    }

    // Assume ET and R are to be provided or are fixed for calculation demo
    // For demonstration, let's assume:
    const ET = 0.25; // example evapotranspiration rate inches/day
    const R = 0.05;  // example rainfall inches/day

    // For each zone, calculate runtime
    const zones = [];
    [...zonesContainer.children].forEach(row => {
      const name = row.querySelector(".zone-name").value.trim() || "(Unnamed Zone)";
      const rateStr = row.querySelector(".rate").value.trim();
      const Rate = parseFloat(rateStr);
      if (!name || isNaN(Rate) || Rate <= 0) {
        // skip invalid zones
        return;
      }
      zones.push({ name, Rate });
    });

    if (zones.length === 0) {
      formulaError.textContent = "No valid zones found.";
      resultsDiv.style.display = "none";
      return;
    }

    const W = wateringFrequency;
    const ETreplace = etReplacementPercent / 100;

    zones.forEach(({ name, Rate }) => {
      try {
        // Evaluate formula replacing tokens
        // Replace ET with (ET * ETreplace) in formula tokens by modifying tokens temporarily
        // But since formula tokens use 0.75 (or other number) for ETreplace, formula is ready
        // So we just supply ET, R, W, Rate

        const value = evaluateFormula(formulaTokens, { ET, R, W, Rate, ETreplace });
        const minutes = Math.max(0, value);
        const rounded = Math.round(minutes * 100) / 100;

        const zoneResult = document.createElement("div");
        zoneResult.textContent = `${name}: ${rounded} minutes`;
        resultsDiv.appendChild(zoneResult);
      } catch (e) {
        formulaError.textContent = `Error calculating zone ${name}: ${e.message}`;
        resultsDiv.style.display = "none";
      }
    });

    saveAllInputsToStorage();
  });

  // Reset button handler
  resetBtn.addEventListener("click", resetToDefaults);

  // Initialize
  loadAllInputsFromStorage();
})();
</script>
</body>
</html>
